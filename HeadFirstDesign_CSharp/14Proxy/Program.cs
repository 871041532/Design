using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _14Proxy
{
    class Program
    {
        /*
         * 代理模式
         * 为另一个对象提供一个替身或占位符以控制对这个对象的访问。使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象，创建开销大的对象或需要安全控制的对象。
         * 
         * 
         *代理模式两个核心：控制和管理访问。可以保护对象避免不想要的访问，也可以避免在加载大对象的过程中GUI会挂起，或者隐藏主题在远程运行的事实。
         * 代理模式可能有许多种,它们的共同点：都会将客户对主题施加的方法调用拦截下来，这种间接的级别让我们可以做许多事，包括将请求分别发送到远程主题；给创建开销大的的对象提供代表；或者提供某些级别的保护，这种保护能决定哪些可以能调用哪些方法。
         * 
         * 远程代理，就好比“远程对象的本地代表”。这是一种可以由本地方法调用的对象，其行为会转发到远程对象中。
         *      
         * 虚拟代理，作为创建开销大的对象的代表。虚拟代理经常直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。
         * 
         * 防火墙代理，控制网络资源的访问，保护主题免于“坏客户”的侵害。
         * 
         * 智能引用代理，当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数。
         * 
         * 缓存代理，为开销大的运算结果提供暂时存储，它也允许多个用户共享结果，以减少计算或网络延迟。
         * 
         * 同步代理，在多线程的情况下为主题提供安全的访问。
         * 
         * 复杂隐藏代理，用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时候也成为外观代理，这不难理解。复杂隐藏代理和外观模式是不一样的，因为代理控制访问，而外观模式只提供另一组接口。
         * 
         * 写入时复制代理，用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要位置。这是虚拟代理的变体。
         */


        static void Main(string[] args)
        {
            Console.ReadLine();
        }
    }
}
