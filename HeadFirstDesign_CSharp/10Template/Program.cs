using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _10Template
{
    class Program
    {
        //模板模式template
        /*
         * 模板方法模式
         * 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
         * 模板方法模式定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。
         * 
         * 例子：在UI框架中，每个view都有init(),onClose(),onTouch(),onDispose()等方法，每个view的生命周期基本是相同的，只是一些方法需要不同实现。把这些相似的方法抽象泛化出来放入ViewBase中，ViewBase亲自执行每个方法，一些步骤方法因为多态特性根据具体子类实现。
         * 
         * 
         * 钩子：抽象类中也可以有默认不做事的方法，称这种方法为“hook”钩子。钩子作用一方面可以让子类实现或不实现算法中可选的部分，另一方面让子类有机会对模板方法中某些即将发生的或刚刚发生的步骤作出反应。
         * 
         * 
         * 钩子与抽象方法的区别：
         * 子类必须提供算法中某个方法或步骤的实现时就使用抽象方法，如果算法的这个步骤是可选的那么就使用钩子。
         * 
         * 
         * 模板方法模式使用原则：
         * 保持抽象方法的数目越少越好，否则在子类中实现这些方法将会很麻烦。想要做到这一点，可以让算法内的步骤不要切割得太细，但是如果步骤太少的话，会比较没有弹性，所以要看情况折衷。
         * 
         * 
         * 依赖腐败：
         * 当高层组件依赖低层组件，而低层组件又依赖高层组件，而高层组件又依赖边侧组件，边侧组件又依赖低层组件时依赖腐败就发生了。在这种情况下，没有人可以轻易地搞懂系统是如何设计的。
         * 
         * 好莱坞原则：
         * 别调用（打电话给）我们，我们会调用（打电话给）你。
         * 在此原则下，允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。换句话说，高层组件对待低层组件的方式是"别调用我们，我们会调用你"。
         * 
         * 
         * 工厂策略模板区别：
         * 模板方法->子类决定如何实现算法中的步骤。（使用继承，算法的部分步骤）
         * 策略->封装可互换的行为，然后使用委托来决定要采用哪一个行为。（使用组合，算法的全部）
         * 工厂方法->由子类决定实例化哪个具体类。
         */
        static void Main(string[] args)
        {
            CaffeineBeverage coffee = new Coffee();
            coffee.prepareRecipe();
            Console.WriteLine();

            CaffeineBeverage tea = new Tea();
            tea.prepareRecipe();
            Console.ReadLine();
        }
    }
}
